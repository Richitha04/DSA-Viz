[
  {
    "type": "debugging",
    "question": "Bug in in-order traversal: nodes not visited in correct order.",
    "code": "def inorder(root):\n    if root:\n        inorder(root.left)\n        inorder(root.right)\n        print(root.val)",
    "answer": "The current node's value should be printed between the recursive calls to left and right subtrees.",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["inorder traversal", "binary tree"],
    "explanation": "In in-order traversal, the sequence is: left subtree, current node, right subtree."
  },
  {
    "type": "debugging",
    "question": "Bug in checking if two trees are identical.",
    "code": "def is_same_tree(p, q):\n    if not p and not q:\n        return True\n    if p.val == q.val:\n        return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n    return False",
    "answer": "Missing check for cases where one node is None and the other is not.",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["tree comparison", "recursion"],
    "explanation": "Before comparing values, ensure both nodes are not None to avoid AttributeError."
  },
  {
    "type": "debugging",
    "question": "Bug in calculating the height of a binary tree.",
    "code": "def height(root):\n    if root is None:\n        return 0\n    return 1 + max(height(root.left), height(root.right))",
    "answer": "The base case should return -1 if height of empty tree is defined as -1.",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["tree height", "recursion"],
    "explanation": "Definition of height varies; adjust base case accordingly."
  },
  {
    "type": "debugging",
    "question": "Bug in inserting a node into a binary search tree.",
    "code": "def insert(root, key):\n    if root is None:\n        root = Node(key)\n    elif key < root.val:\n        insert(root.left, key)\n    else:\n        insert(root.right, key)\n    return root",
    "answer": "Missing assignment when inserting into left or right subtree.",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["bst insertion", "recursion"],
    "explanation": "Need to assign the result of recursive call to root.left or root.right."
  },
  {
    "type": "debugging",
    "question": "Bug in checking if a binary tree is balanced.",
    "code": "def is_balanced(root):\n    if root is None:\n        return True\n    left = height(root.left)\n    right = height(root.right)\n    if abs(left - right) <= 1:\n        return True\n    return False",
    "answer": "Need to check if left and right subtrees are also balanced.",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["balanced tree", "recursion"],
    "explanation": "A tree is balanced if left and right subtrees are balanced and their heights differ by no more than 1."
  },
  {
    "type": "debugging",
    "question": "Bug in pre-order traversal: incorrect order of node visits.",
    "code": "def preorder(root):\n    if root:\n        preorder(root.left)\n        print(root.val)\n        preorder(root.right)",
    "answer": "The current node's value should be printed before traversing left and right subtrees.",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["preorder traversal", "binary tree"],
    "explanation": "In pre-order traversal, the sequence is: current node, left subtree, right subtree."
  },
  {
    "type": "debugging",
    "question": "Bug in post-order traversal: nodes not visited in correct order.",
    "code": "def postorder(root):\n    if root:\n        print(root.val)\n        postorder(root.left)\n        postorder(root.right)",
    "answer": "The current node's value should be printed after traversing left and right subtrees.",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["postorder traversal", "binary tree"],
    "explanation": "In post-order traversal, the sequence is: left subtree, right subtree, current node."
  },
  {
    "type": "debugging",
    "question": "Bug in finding the minimum value in a BST.",
    "code": "def find_min(root):\n    while root.left is not None:\n        root = root.right\n    return root.val",
    "answer": "Should traverse to the leftmost node, not the right.",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["bst", "minimum value"],
    "explanation": "In BST, the minimum value is at the leftmost node."
  },
  {
    "type": "debugging",
    "question": "Bug in counting the number of nodes in a binary tree.",
    "code": "def count_nodes(root):\n    if root is None:\n        return 0\n    return count_nodes(root.left) + count_nodes(root.right)",
    "answer": "Missing count for the current node.",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["node count", "recursion"],
    "explanation": "Should add 1 for the current node to the sum of left and right subtree counts."
  },
  {
    "type": "debugging",
    "question": "Bug in checking if a binary tree is a BST.",
    "code": "def is_bst(root):\n    if root is None:\n        return True\n    if root.left and root.left.val > root.val:\n        return False\n    if root.right and root.right.val < root.val:\n        return False\n    return is_bst(root.left) and is_bst(root.right)",
    "answer": "Need to check all nodes in left subtree are less than root and all in right are greater, not just immediate children.",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["bst validation", "recursion"],
    "explanation": "Must pass down min and max constraints to validate entire subtree."
  },
  {
    "type": "debugging",
    "question": "Bug in finding lowest common ancestor (LCA) in a binary tree.",
    "code": "def lca(root, p, q):\n    if root == None:\n        return None\n    if root == p or root == q:\n        return root\n    left = lca(root.left, p, q)\n    right = lca(root.right, p, q)\n    if left and right:\n        return root\n    return root",
    "answer": "Should return left or right, not root, when only one is found.",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["lca", "binary tree"],
    "explanation": "If only one subtree returns a match, the answer lies in that subtree."
  },
  {
    "type": "debugging",
    "question": "Bug in serializing a binary tree.",
    "code": "def serialize(root):\n    if not root:\n        return ''\n    return str(root.val) + serialize(root.left) + serialize(root.right)",
    "answer": "Need to include markers for null nodes to avoid ambiguity during deserialization.",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["serialization", "binary tree"],
    "explanation": "Without null markers, tree structure cannot be reconstructed uniquely."
  },
  {
    "type": "debugging",
    "question": "Bug in mirroring a binary tree.",
    "code": "def mirror(root):\n    if not root:\n        return\n    root.left = mirror(root.right)\n    root.right = mirror(root.left)",
    "answer": "Recursive calls should be stored in temporary variables to avoid using updated references.",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["mirror tree", "recursion"],
    "explanation": "Calling mirror modifies left/right before the other side is evaluated."
  },
  {
    "type": "debugging",
    "question": "Bug in checking if a binary tree is symmetric.",
    "code": "def is_symmetric(root):\n    def is_mirror(t1, t2):\n        if not t1 and not t2:\n            return True\n        if not t1 or not t2:\n            return False\n        return is_mirror(t1.left, t2.left) and is_mirror(t1.right, t2.right)\n    return is_mirror(root.left, root.right)",
    "answer": "Should check mirrored children: left with right and right with left.",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["symmetric tree", "mirror"],
    "explanation": "To be symmetric, left of one must match right of the other."
  },
  {
    "type": "debugging",
    "question": "Bug in level-order traversal: output is not grouped by levels.",
    "code": "def level_order(root):\n    if not root:\n        return []\n    q = [root]\n    res = []\n    while q:\n        node = q.pop(0)\n        res.append([node.val])\n        if node.left:\n            q.append(node.left)\n        if node.right:\n            q.append(node.right)\n    return res",
    "answer": "Need to use a nested loop or track level size to group by level.",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["bfs", "level-order"],
    "explanation": "Each level should be processed and grouped together."
  },
  {
    "type": "debugging",
    "question": "Bug in computing diameter of a binary tree.",
    "code": "def diameter(root):\n    if not root:\n        return 0\n    left = height(root.left)\n    right = height(root.right)\n    return max(left + right, diameter(root.left), diameter(root.right))",
    "answer": "height function is called multiple times unnecessarily, leading to inefficiency.",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["diameter", "recursion"],
    "explanation": "Use helper function to compute height and update diameter in one pass."
  },
  {
    "type": "debugging",
    "question": "Bug in tree flattening to a linked list (right-skewed).",
    "code": "def flatten(root):\n    if not root:\n        return\n    flatten(root.left)\n    flatten(root.right)\n    temp = root.right\n    root.right = root.left\n    root.left = None\n    while root.right:\n        root = root.right\n    root.right = temp",
    "answer": "Traversal modifies the root during recursion; store root before traversing.",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["flatten tree", "recursion"],
    "explanation": "Changing root.right during recursion breaks structure. Use a helper with return value."
  },
  {
    "type": "debugging",
    "question": "Bug in converting sorted array to balanced BST.",
    "code": "def sorted_array_to_bst(nums):\n    if not nums:\n        return None\n    mid = len(nums) // 2\n    root = TreeNode(nums[mid])\n    root.left = sorted_array_to_bst(nums[:mid])\n    root.right = sorted_array_to_bst(nums[:mid])\n    return root",
    "answer": "Right subtree should use nums[mid+1:], not nums[:mid].",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["bst", "recursion"],
    "explanation": "Left gets left half, right gets right half after mid."
  },
  {
    "type": "debugging",
    "question": "Bug in path sum check from root to leaf.",
    "code": "def has_path_sum(root, target):\n    if not root:\n        return False\n    if not root.left and not root.right:\n        return root.val == target\n    return has_path_sum(root.left, target) or has_path_sum(root.right, target)",
    "answer": "Missing subtraction of root.val from target in recursive calls.",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["path sum", "recursion"],
    "explanation": "Target must be reduced by current node value before going deeper."
  },
  {
    "type": "debugging",
    "question": "Bug in deleting a node from a BST.",
    "code": "def delete_node(root, key):\n    if not root:\n        return root\n    if key < root.val:\n        root.left = delete_node(root.left, key)\n    elif key > root.val:\n        root.right = delete_node(root.right, key)\n    else:\n        if not root.left:\n            return root.right\n        if not root.right:\n            return root.left\n        temp = find_min(root.right)\n        root.val = temp.val\n    return root",
    "answer": "Missing deletion of the in-order successor after replacement.",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["bst deletion", "recursion"],
    "explanation": "After replacing with successor, must delete the successor node recursively."
  },
  {
    "type": "debugging",
    "question": "Bug in recovering BST where two nodes are swapped.",
    "code": "def recover_bst(root):\n    prev = TreeNode(float('-inf'))\n    def inorder(node):\n        nonlocal prev\n        if not node:\n            return\n        inorder(node.left)\n        if node.val < prev.val:\n            node.val, prev.val = prev.val, node.val\n        prev = node\n        inorder(node.right)\n    inorder(root)",
    "answer": "Only swaps first out-of-order pair; need to track both first and second misplaced nodes.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["recover bst", "morris traversal"],
    "explanation": "Track two nodes and swap after complete traversal."
  },
  {
    "type": "debugging",
    "question": "Bug in building tree from preorder and inorder traversal arrays.",
    "code": "def build_tree(preorder, inorder):\n    if not preorder or not inorder:\n        return None\n    root = TreeNode(preorder.pop(0))\n    idx = inorder.index(root.val)\n    root.left = build_tree(preorder, inorder[:idx])\n    root.right = build_tree(preorder, inorder[idx+1:])\n    return root",
    "answer": "Popping from preorder breaks recursion due to slicing of inorder.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["construct tree", "recursion"],
    "explanation": "Use indices instead of slicing to maintain correct preorder references."
  },
  {
    "type": "debugging",
    "question": "Bug in counting unival subtrees.",
    "code": "def count_unival_subtrees(root):\n    count = 0\n    def is_unival(node):\n        nonlocal count\n        if not node:\n            return True\n        left = is_unival(node.left)\n        right = is_unival(node.right)\n        if left and right:\n            count += 1\n            return True\n        return False\n    is_unival(root)\n    return count",
    "answer": "Need to check if node's children have the same value as the node.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["unival", "recursion"],
    "explanation": "A subtree is unival if it's children are unival and match the node's value."
  },
  {
    "type": "debugging",
    "question": "Bug in Morris in-order traversal (no recursion, no stack).",
    "code": "def morris_inorder(root):\n    res = []\n    while root:\n        if not root.left:\n            res.append(root.val)\n            root = root.right\n        else:\n            pred = root.left\n            while pred.right:\n                pred = pred.right\n            pred.right = root\n            root = root.left\n    return res",
    "answer": "Missing restoration of the tree structure after threading.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["morris traversal", "threaded binary tree"],
    "explanation": "Must break the thread after visiting left subtree."
  },
  {
    "type": "debugging",
    "question": "Bug in tree-to-DLL conversion.",
    "code": "def tree_to_dll(root):\n    def convert(node):\n        if not node:\n            return None\n        l = convert(node.left)\n        r = convert(node.right)\n        if l:\n            while l.right:\n                l = l.right\n            l.right = node\n            node.left = l\n        if r:\n            node.right = r\n            r.left = node\n        return node\n    return convert(root)",
    "answer": "Returning root each time loses access to the head of the list.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["binary tree", "dll"],
    "explanation": "Need to track and return head of DLL from conversion."
  },
  {
    "type": "interview",
    "question": "Explain how you would find the diameter of a binary tree and implement it efficiently.",
    "expected_answer": "Use a recursive helper that computes the height of each subtree while updating the maximum diameter found. The diameter is the sum of the heights of left and right subtrees.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["binary tree", "diameter"],
    "explanation": "This requires understanding how to optimize recursion to avoid redundant height calculations."
  },
  {
    "type": "interview",
    "question": "How do you convert a Binary Tree to a Doubly Linked List in-place?",
    "expected_answer": "Use in-order traversal and modify the left and right pointers to behave like previous and next pointers. Maintain a previous node pointer to link the current node.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["tree to dll", "in-place"],
    "explanation": "Requires in-depth pointer manipulation and traversal understanding."
  },
  {
    "type": "interview",
    "question": "Explain the Morris Traversal algorithm and its advantage.",
    "expected_answer": "Morris Traversal uses threaded binary trees to perform in-order traversal without recursion or a stack. It modifies the tree temporarily to create threads and restores it after traversal.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["morris traversal", "advanced traversal"],
    "explanation": "Efficient O(1) space complexity without stack or recursion."
  },
  {
    "type": "interview",
    "question": "How would you recover a Binary Search Tree where two nodes are swapped?",
    "expected_answer": "Use in-order traversal to detect two nodes where the BST property is violated, store the first and last offending nodes, and swap their values after traversal.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["bst", "inorder", "recovery"],
    "explanation": "Involves careful state tracking during in-order traversal."
  },
  {
    "type": "interview",
    "question": "Design a data structure that supports insert, delete, find, and getRandomNode in a Binary Tree in O(1) time.",
    "expected_answer": "Use a combination of a list to store nodes and a hash map to maintain value-to-index mappings, ensuring constant-time operations.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["design", "random node"],
    "explanation": "Complexity lies in balancing tree structure and random access."
  },
  {
    "type": "interview",
    "question": "How do you serialize and deserialize a binary tree efficiently?",
    "expected_answer": "Use pre-order traversal for serialization and a recursive function that uses a queue or iterator for deserialization. Include null markers to preserve structure.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["serialization", "tree reconstruction"],
    "explanation": "Needs a complete solution for tree state preservation."
  },
  {
    "type": "interview",
    "question": "How would you construct a binary tree from its in-order and post-order traversals?",
    "expected_answer": "Use recursion where the last element in post-order is the root. Find that root in in-order to divide into left and right subtrees, then recurse.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["tree construction", "recursion"],
    "explanation": "Requires managing two traversal lists and their indices carefully."
  },
  {
    "type": "interview",
    "question": "How would you find the largest BST subtree in a binary tree?",
    "expected_answer": "Use post-order traversal to validate each subtree. Return size if it's a BST; otherwise, return the largest size from children.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["bst", "subtree analysis"],
    "explanation": "Challenging due to needing to check BST validity recursively."
  },
  {
    "type": "interview",
    "question": "Design an algorithm to check if a binary tree is a subtree of another binary tree.",
    "expected_answer": "Use tree traversal to compare nodes. For each node in the larger tree, use a helper to compare it structurally to the smaller tree.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["subtree", "comparison"],
    "explanation": "Requires precise structural and value matching of two trees."
  },
  {
    "type": "interview",
    "question": "How do you implement an in-order iterator for a binary tree?",
    "expected_answer": "Use a stack to simulate the recursive traversal. Push all left children at initialization, and during each call to next(), push the left path of the right child.",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["iterator", "inorder traversal"],
    "explanation": "Requires understanding lazy traversal and data structure simulation."
  }
] 